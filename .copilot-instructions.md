# GitHub Copilot Instructions for iRPC

## Project Overview

iRPC is a Rust library providing a robotic node interaction protocol that supports both standard host environments and no_std embedded environments through feature-gated architecture.

## Architecture & Features

- **`arm_api` feature**: Enables std environment support with async runtime (tokio) and logging (tracing)
- **`joint_api` feature**: Enables no_std embedded environment support with synchronous APIs
- **Feature-gated design**: Code is conditionally compiled based on target environment
- **Protocol-agnostic**: Core protocol definitions work across both environments

## Rust Development Guidelines

### Code Style & Patterns

- Follow Rust 2021 edition conventions
- Use `#![cfg_attr(not(feature = "arm_api"), no_std)]` for no_std compatibility
- Prefer `const fn` constructors for embedded-friendly APIs
- Use `Result<T, ProtocolError>` for all fallible operations
- Implement `Clone` and `Debug` for data types when possible

### Feature-Gated Development

**When adding std-only code:**
```rust
#[cfg(feature = "arm_api")]
use std::vec::Vec;
#[cfg(feature = "arm_api")]
use tokio::sync::mpsc;
```

**When adding no_std code:**
```rust
#[cfg(not(feature = "arm_api"))]
extern crate alloc;
#[cfg(not(feature = "arm_api"))]
use alloc::vec::Vec;
```

**For universal code:**
```rust
// Import std types when arm_api feature is enabled, otherwise use no_std alternatives
#[cfg(feature = "arm_api")]
use std::vec::Vec;
#[cfg(feature = "arm_api")]
use std::string::String;

#[cfg(not(feature = "arm_api"))]
extern crate alloc;
#[cfg(not(feature = "arm_api"))]
use alloc::vec::Vec;
#[cfg(not(feature = "arm_api"))]
use alloc::string::String;
```

### Embedded/No_std Guidelines

- Always use `const` constructors where possible: `pub const fn new() -> Self`
- Avoid dynamic allocation in embedded code paths
- Use fixed-size buffers: `buffer: [u8; 256]`
- Prefer non-blocking operations: `try_receive()` instead of `receive()`
- Document memory usage and constraints
- Test with `--no-default-features --features joint_api`

### Async Guidelines (arm_api feature)

- Use `async fn` for I/O operations in std environments
- Prefer `tokio::sync` primitives over std::sync
- Use `tracing` for logging instead of `println!`
- Return `Result<T, ProtocolError>` from async functions
- Test async code with `#[tokio::test]`

### Error Handling

- Use the existing `ProtocolError` enum for all library errors
- Convert external errors to `ProtocolError::IoError(String)`
- Provide meaningful error messages for embedded debugging
- Avoid panics in library code; use `Result` types

### Testing Guidelines

- Feature-gate tests: `#[cfg(feature = "arm_api")]` and `#[cfg(feature = "joint_api")]`
- Test both sync and async APIs where applicable
- Use integration tests for cross-feature validation
- Test with different feature combinations:
  - `cargo test --no-default-features --features arm_api`
  - `cargo test --no-default-features --features joint_api`
  - `cargo test --features arm_api,joint_api`

### Documentation

- Document feature requirements: `/// Available only with the `arm_api` feature.`
- Include usage examples for both environments
- Document memory constraints for embedded APIs
- Use `#[doc(cfg(feature = "..."))]` for feature-gated items

### Module Organization

- `protocol.rs`: Core protocol definitions (universal)
- `bus.rs`: Communication bus abstractions (universal)
- `arm.rs`: Host environment APIs (arm_api feature only)
- `joint.rs`: Embedded environment APIs (joint_api feature only)

### Performance Considerations

- Embedded: Minimize heap allocations, prefer stack-based operations
- Host: Leverage async I/O for concurrent operations
- Use `#[inline]` for hot path functions
- Consider const generics for buffer sizes

### Dependencies

- Only add dependencies that support no_std when needed by embedded features
- Use optional dependencies activated by features
- Prefer `core` and `alloc` over `std` in universal code
- Document MSRV (Minimum Supported Rust Version) requirements